a=[1,2,3,4,5,6]
for i in a:
    if i==3:



    def executeStringRemoval(self, avgCusRmvd, maxStringLen, randomGen):
        """_summary_

        Args:
            avgCusRmvd (_type_): _description_
            maxStringLen (_type_): _description_
            randomGen (_type_): _description_
        """
        avgNodesPerRoute = (len(self.instance.allNodes) - 1) // len(self.solution.routes)
        # record average number of nodes per route
        l_max_s = min(maxStringLen, avgNodesPerRoute)
        # max string length. cannot totally remove a route ?
        k_max_s = (4 * avgCusRmvd) / (1 + l_max_s) - 1
        # print(f"k_max_s {k_max_s}", end = " ")
        # the maximum number of strings
        k_s = int(randomGen.uniform(1, k_max_s + 1))
        # the number of strings to be removed for this solution ...
        cus_seed = randomGen.choice(self.solution.served)
        cusSeedId = cus_seed.id
        # find the seed customer where the string removal begins
        visitedCusId = [-1 for _ in range(self.instance.numNodes)]
        # to restore deleted customers id that have been removed ...
        cusEnRouteList = [-1 for _ in range(self.instance.numNodes)]
        enRouteCusDict = dict()
        enRouteCusSeqDict = dict()
        # record the following:
        # 1. the route of each customer,
        # 2. the customers each route served ...
        # 3. the sequence of customers each route served ...
        for idx, route in enumerate(self.solution.routes):
            enRouteCusDict[idx] = []
            enRouteCusSeqDict[idx] = []
            for node in route.nodes:
                if node.id != 0:
                    cusEnRouteList[node.id] = idx
                    enRouteCusDict[idx].append(node.id)
                enRouteCusSeqDict[idx].append(node.id)

        for nodeId in enRouteCusDict[cusEnRouteList[cusSeedId]]:
            visitedCusId[nodeId] = 1
        visitedCusId[0] = 1
        # keep track of visited customers ...

        entireRouteRemoval = [] # record routes that are entirely removed ...
        for i in range(k_s):
            # need to remove k_s routes ...
            for customer_id in self.instance.adjDistMatrix[cusSeedId]:
                # iterate over all nodes ...
                if visitedCusId[customer_id] == 1 or customer_id == 0:
                    # if the customer has been visited, or if the customer is depot, skip it ...
                    continue
                else:
                    # if the customer has not been visited, add it to the visited list ...
                    # this tour is the next string ...
                    # determine the l_max_t, l_t (removed string length)
                    routeIdx = cusEnRouteList[customer_id]
                    l_max_t = min(len(enRouteCusDict[routeIdx]), l_max_s)
                    l_t = int(randomGen.uniform(1, l_max_t))

                    curRoute = enRouteCusSeqDict[routeIdx]
                    # print(curRoute, l_t, routeIdx)
                    rmvdIdxes = self.chooseCusViaString(customer_id, enRouteCusSeqDict[routeIdx], l_t, randomGen)
                    if len(rmvdIdxes) == len(curRoute):
                        # The route is actually entirely removed ...
                        entireRouteRemoval.append(routeIdx)
                    self.solution.removeRouteString(routeIdx, rmvdIdxes)
                    for sameRouteCusId in enRouteCusDict[routeIdx]:
                        visitedCusId[sameRouteCusId] = 1
                    # print(f"Current Visited Cus ID : {visitedCusId}")
                    cusSeedId = customer_id
                    break

        if len(entireRouteRemoval) > 0:
            sorted(entireRouteRemoval)
            for routeIdx in entireRouteRemoval[::-1]:
                # backward update to avoid index conflict ...
                self.solution.routes.pop(routeIdx)



































                if pre==succ:
                    cost=self.instance.distMatrix[self.nodes[pre].id][pickup.id]+\
                         pickup.serviceTime+\
                         self.instance.distMatrix[pickup.id][delivery.id]+\
                         delivery.serviceTime+\
                         self.instance.distMatrix[delivery.id][self.nodes[pre+1].id]-\
                         self.instance.distMatrix[self.nodes[pre].id][self.nodes[pre + 1].id]
                    #违反时间窗
                    if self.forwardTimeSlack[pre+1]<cost:
                        continue
                    if self.serviceStartTime[pre]+self.nodes[pre].serviceTime+\
                            self.instance.distMatrix[self.nodes[pre].id][pickup.id]>pickup.dueTime:
                        continue
                    if self.serviceStartTime[pre]+self.nodes[pre].serviceTime+\
                            self.instance.distMatrix[self.nodes[pre].id][pickup.id]+\
                            pickup.serviceTime+\
                            self.instance.distMatrix[pickup.id][delivery.id]\
                            >delivery.dueTime:
                        continue
                    iters.append([pre,succ,cost])
                else:
                    #pickup节点
                    cost_pre=self.instance.distMatrix[self.nodes[pre].id][pickup.id]+\
                             pickup.serviceTime+\
                             self.instance.distMatrix[pickup.id][self.nodes[pre+1].id]- \
                             self.instance.distMatrix[self.nodes[pre].id][self.nodes[pre + 1].id]
                    if self.forwardTimeSlack[pre+1]<cost_pre:
                        continue
                    if self.serviceStartTime[pre]+self.nodes[pre].serviceTime+\
                            self.instance.distMatrix[self.nodes[pre].id][pickup.id]>pickup.dueTime:
                        continue
                    #delivery节点
                    cost_succ=self.instance.distMatrix[self.nodes[succ].id][delivery.id]+\
                              delivery.serviceTime+\
                              self.instance.distMatrix[delivery.id][self.nodes[succ+1].id]- \
                              self.instance.distMatrix[self.nodes[succ].id][self.nodes[succ + 1].id]

                    newlist=[pickup]+self.nodes[pre:succ+1]+[delivery]
                    middlelong=sum(newlist[i].serviceTime+self.instance.distMatrix[newlist[i].id][newlist[i+1].id] for i in range(len(newlist)-1))+delivery.serviceTime
                    if self.forwardTimeSlack[succ+1]<self.serviceStartTime[pre]+self.nodes[pre].serviceTime+\
                            self.instance.distMatrix[self.nodes[pre].id][pickup.id]+\
                            middlelong+\
                            self.instance.distMatrix[delivery.id][self.nodes[succ+1].id]-\
                            self.serviceStartTime[succ]-\
                            self.nodes[succ].serviceTime-\
                            self.instance.distMatrix[self.nodes[succ].id][self.nodes[succ + 1].id]:
                        continue
                    if self.serviceStartTime[pre]+self.nodes[pre].serviceTime+\
                            self.instance.distMatrix[self.nodes[pre].id][pickup.id]+\
                            middlelong+\
                            self.instance.distMatrix[delivery.id][self.nodes[succ+1].id]>delivery.dueTime:
                        continue
                    cost=cost_pre+cost_succ
                    iters.append([pre,succ,cost])


import sys

class Route:
    # 原有代码保持不变...

    def getalliters(self, pickup, delivery):
        iters = []
        for pre in range(len(self.nodes) - 1):
            for succ in range(pre, len(self.nodes) - 1):
                # 检查容量约束
                new_loads = self.curLoad.copy()
                for i in range(pre + 1, len(new_loads)):
                    if i <= succ + 1:
                        new_loads[i] += pickup.demand
                    if i > succ + 1:
                        new_loads[i] += delivery.demand
                    if new_loads[i] > self.instance.capacity:
                        break
                else:
                    # 容量约束满足，检查时间窗口约束
                    newlist = [self.nodes[pre], pickup] + self.nodes[pre + 1:succ + 1] + [delivery, self.nodes[succ + 1]]
                    servicestarttime = self.serviceStartTime[pre]
                    skip = False
                    for i, node in enumerate(newlist):
                        if i == 0:
                            continue
                        actualArrivalTime = servicestarttime + newlist[i - 1].serviceTime + self.instance.distMatrix[newlist[i - 1].id][newlist[i].id]
                        if actualArrivalTime > node.dueTime:
                            skip = True
                            break
                        servicestarttime = max(node.readyTime, actualArrivalTime)
                    if not skip:
                        # 时间窗口约束满足，检查时间松弛约束
                        new_forward_time_slack = self.forwardTimeSlack.copy()
                        for i in range(succ + 2, len(new_forward_time_slack)):
                            new_forward_time_slack[i] -= (self.instance.distMatrix[self.nodes[succ].id][delivery.id] + delivery.serviceTime + self.instance.distMatrix[delivery.id][self.nodes[succ + 1].id] - self.instance.distMatrix[self.nodes[succ].id][self.nodes[succ + 1].id])
                        if servicestarttime - self.instance.distMatrix[delivery.id][self.nodes[succ + 1].id] - delivery.serviceTime <= new_forward_time_slack[succ + 1]:
                            # 所有约束都满足，计算成本
                            if pre == succ:
                                cost = self.instance.distMatrix[self.nodes[pre].id][pickup.id] + \
                                       pickup.serviceTime + \
                                       self.instance.distMatrix[pickup.id][delivery.id] + \
                                       delivery.serviceTime + \
                                       self.instance.distMatrix[delivery.id][self.nodes[pre + 1].id] - \
                                       self.instance.distMatrix[self.nodes[pre].id][self.nodes[pre + 1].id]
                            else:
                                cost_pre = self.instance.distMatrix[self.nodes[pre].id][pickup.id] + \
                                           pickup.serviceTime + \
                                           self.instance.distMatrix[pickup.id][self.nodes[pre + 1].id] - \
                                           self.instance.distMatrix[self.nodes[pre].id][self.nodes[pre + 1].id]
                                cost_succ = self.instance.distMatrix[self.nodes[succ].id][delivery.id] + \
                                            delivery.serviceTime + \
                                            self.instance.distMatrix[delivery.id][self.nodes[succ + 1].id] - \
                                            self.instance.distMatrix[self.nodes[succ].id][self.nodes[succ + 1].id]
                                cost = cost_pre + cost_succ
                            iters.append([pre, succ, cost])
        return iters

    # 原有代码保持不变...